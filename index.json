[{"content":" @Transactional失效 整合shiro之后，UserRealm类里自动注入的service中的@Transactional注解失效\n解决方法 使用@Lazy注解\n1 2 3 @Autowired @Lazy private OperationUnitService operationUnitService; 在Realm中直接使用mapper，而不是service\n1 2 @Autowired private OperationUnitMapper operationUnitMapper; ApplicationContextRegister.getBean()方法，手动注入bean\n1 OperationUnitService operationUnitService = ApplicationContextRegister.getBean(OperationUnitService.class) 产生原因 在shiro中为了引入权限注解，配置了defaultAdvisorAutoProxyCreator和authorizationAttributeSourceAdvisor类，他们是通过AOP方式对@RequiredPermission类/方法(权限控制)进行增强.\n生成对应的代理类对象，由于shiroFilterFactoryBean实现了factoryBean接口，所以会被提前初始化，所以引发所有相关的bean提前初始化，导致他们没有被事务AOP包裹着，从而引发事务无效的问题\n1 2 3 4 5 6 7 8 9 10 11 /** * 开启Shiro的注解(如@RequiresRoles,@RequiresPermissions),需借助SpringAOP扫描使用Shiro注解的类,并在必要时进行安全逻辑验证 * 配置以下两个bean(DefaultAdvisorAutoProxyCreator(可选)和AuthorizationAttributeSourceAdvisor)即可实现此功能 */ @Bean @DependsOn({\u0026#34;lifecycleBeanPostProcessor\u0026#34;}) public DefaultAdvisorAutoProxyCreator advisorAutoProxyCreator() { DefaultAdvisorAutoProxyCreator advisorAutoProxyCreator = new DefaultAdvisorAutoProxyCreator(); advisorAutoProxyCreator.setProxyTargetClass(true); return advisorAutoProxyCreator; } 元素的 \u0026ldquo;proxy-target-class\u0026rdquo; 属性值来控制是基于接口的还是基于类的代理被创建。如果 \u0026ldquo;proxy-target-class\u0026rdquo; 属值被设置为 \u0026ldquo;true\u0026rdquo;，那么基于类的代理将起作用（这时需要CGLIB库cglib.jar在CLASSPATH中）。如果 \u0026ldquo;proxy-target-class\u0026rdquo; 属值被设置为 \u0026ldquo;false\u0026rdquo; 或者这个属性被省略，那么标准的JDK基于接口的代理将起作用。\n工具 快捷查看事务是否生效\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 public class DebugUtils { private static final boolean transactionDebugging = true; private static final boolean verboseTransactionDebugging = true; public static void showTransactionStatus(String message) { System.out.println(((transactionActive()) ? \u0026#34;[+] \u0026#34; : \u0026#34;[-] \u0026#34;) + message); } // Some guidance from: \u0026lt;http://java.dzone.com/articles/monitoring-declarative-transac?page=0,1\u0026gt; public static boolean transactionActive() { try { ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader(); Class tsmClass = contextClassLoader.loadClass(\u0026#34;org.springframework.transaction.support.TransactionSynchronizationManager\u0026#34;); Boolean isActive = (Boolean) tsmClass.getMethod(\u0026#34;isActualTransactionActive\u0026#34;, null).invoke(null, null); return isActive; } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (IllegalArgumentException e) { e.printStackTrace(); } catch (SecurityException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } catch (NoSuchMethodException e) { e.printStackTrace(); } // If we got here it means there was an exception throw new IllegalStateException(\u0026#34;ServerUtils.transactionActive was unable to complete properly\u0026#34;); } public static void transactionRequired(String message) { // Are we debugging transactions? if (!transactionDebugging) { // No, just return return; } // Are we doing verbose transaction debugging? if (verboseTransactionDebugging) { // Yes, show the status before we get to the possibility of throwing an exception showTransactionStatus(message); } // Is there a transaction active? if (!transactionActive()) { // No, throw an exception throw new IllegalStateException(\u0026#34;Transaction required but not active [\u0026#34; + message + \u0026#34;]\u0026#34;); } } } 在需要检测的地方\n1 DebugUtils.transactionRequired(\u0026#34;OperationUnitServiceImpl.testIn\u0026#34;); ","permalink":"https://habyss.github.io/posts/tech/transactional/","summary":"@Transactional失效 整合shiro之后，UserRealm类里自动注入的service中的@Transactional注解失效 解","title":"@Transactional失效排查"},{"content":"$ref-fastjson 问题排查 问题排查 项目返回的数据中出现$ref数据\n查询得知是fastjson的特性循环引用 fastjson支持循环引用，并且是缺省打开的。\n当序列化后的JSON传输到浏览器或者其他语言中，这些json解析器不支持循环引用，从而导致数据丢失。你可以关闭fastjson的循环引用支持。关闭引用检测，还能够提升序列化时的性能。\n全局配置关闭\n1 JSON.DEFAULT_GENERATE_FEATURE |= SerializerFeature.DisableCircularReferenceDetect.getMask(); 非全局关闭\n1 JSON.toJSONString(obj, SerializerFeature.DisableCircularReferenceDetect); 项目中配置了全局默认使用fastjson, 所以导致默认的jackson不生效. $ref-fastjson-解决方案 全局配置关闭\n非全局关闭\n删除全局默认fastjson\n","permalink":"https://habyss.github.io/posts/tech/ref-fastjson/","summary":"$ref-fastjson 问题排查 问题排查 项目返回的数据中出现$ref数据 查询得知是fastjson的特性循环引用 fastjson支持循环引用，并且是缺省打开的。 当","title":"$ref-fastjson排查"},{"content":"SpringBoot中时间戳和LocalDateTime相关的接收和转换 前言 一般情况下, 前端和后端在时间格式的传递上都走的是时间戳（方便前端自由定制） 时间格式由于java8的新增时间处理类比较好用,而且更加线程安全, 所以将项目中的时间相关改为LocalDateTime，而不是传统的Date 前置要求 mybatis需要3.4.6以上, 否则会不支持xml和javaType的转换 druid需要比较新的版本, 这里使用的是1.1.21, 否则查询会报错,结果集result set中找不到元素 正文 请求方式的情况分类\n@RequestBody中修饰LocalDateTime 其他, 比如@RequestParam和@PathVariable以及不加注解的单参数和对象参数 情况一. @RequestBody中的LocalDateTime 通过@RequestBody很明显的就是要通过JSON序列化进行处理，Spring默认的是Jackson进行处理，所以我们需要对默认的JSON处理器进行日期类型的添加(假如默认不带对应序列化器的情况下)\n此时需要用的是JsonDeserializer这个类，对应的实现如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /** * 入参 时间戳 -\u0026gt; LocalDateTime */ public class CustomDateDeserializer { public static class LocalDateTimeDeserializer extends JsonDeserializer\u0026lt;LocalDateTime\u0026gt; { @Override public LocalDateTime deserialize(JsonParser p, DeserializationContext context) throws IOException { Long timestamp = Long.valueOf(p.getText()); Instant instant = Instant.ofEpochMilli(timestamp); return LocalDateTime.ofInstant(instant, ZoneId.systemDefault()); } } } /** * @author kun.han on 2020/3/4 15:45 * 返回参数 LocalDateTime -\u0026gt; 时间戳 */ public class CustomDateSerializer { public static class LocalDateTimeSerializer extends JsonSerializer\u0026lt;LocalDateTime\u0026gt; { @Override public void serialize(LocalDateTime localDateTime, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException { jsonGenerator.writeNumber(localDateTime.toInstant(ZoneOffset.of(\u0026#34;+8\u0026#34;)).toEpochMilli()); } } } 有了这个了类，还需要添加到Spring中，Spring利用的是ObjectMapper，我们自定义一个ObjectMapper替换原本的就可以了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 @Configuration public class CustomDateConfig implements WebMvcConfigurer { /** * Json序列化和反序列化转换器，用于转换Post请求体中的json以及将我们的对象序列化为返回响应的json */ @Bean public ObjectMapper objectMapper() { ObjectMapper objectMapper = new ObjectMapper(); //不显示为null的字段 objectMapper.disable(SerializationFeature.FAIL_ON_EMPTY_BEANS); objectMapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES); // 忽略不能转移的字符 objectMapper.configure(JsonParser.Feature.ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER, true); // 过滤对象的null属性. objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL); //忽略transient objectMapper.configure(MapperFeature.PROPAGATE_TRANSIENT_MARKER, true); objectMapper.disable(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE); //LocalDateTime系列序列化和反序列化模块，继承自jsr310，我们在这里修改了日期格式 JavaTimeModule javaTimeModule = new JavaTimeModule(); // LocalDateTime 这里只需要LocalDateTime 如果需要转其他的,相应放开注释, 并在上面两个类中适当修改 javaTimeModule.addSerializer(LocalDateTime.class, new CustomDateSerializer.LocalDateTimeSerializer()); javaTimeModule.addDeserializer(LocalDateTime.class,new CustomDateDeserializer.LocalDateTimeDeserializer()); // // LocalDate // javaTimeModule.addSerializer(LocalDate.class, new CustomDateSerializer.LocalDateSerializer()); // javaTimeModule.addDeserializer(LocalDate.class, new CustomDateDeserializer.LocalDateDeserializer()); // //Date序列化和反序列化 // javaTimeModule.addSerializer(Date.class,new CustomDateSerializer.DateSerializer()); // javaTimeModule.addDeserializer(Date.class,new CustomDateDeserializer.DateDeserializer()); objectMapper.registerModule(javaTimeModule); return objectMapper; } } 情况二. 其他 比如@RequestParam和@PathVariable以及不加注解的单参数和对象参数 方式一: Convert 可以根据自身需求进行定制，这里我通过Convert转换LocalDateTime为例，进行转换：\n1 2 3 4 5 6 7 8 9 public class CustomDateConverter { public static class LocalDateConvert implements Converter\u0026lt;String, LocalDateTime\u0026gt; { @Override public LocalDateTime convert(String timestamp) { return LocalDateTime.ofInstant(Instant.ofEpochMilli(Long.parseLong(timestamp)), ZoneId.systemDefault()); } } } 同样的需要在配置类中引用\n1 2 3 4 5 6 7 8 @Configuration public class CustomDateConfig implements WebMvcConfigurer { @Bean public Converter\u0026lt;String, LocalDateTime\u0026gt; localDateConverter() { //此处不能替换为lambda表达式 return new CustomDateConverter.LocalDateConvert(); } } 方式二: ControllerAdvice 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 /** * requestBody之外的入参 时间戳-\u0026gt;LocalDateTime * * @author hankun */ @ControllerAdvice public class LocalDateTimeAdvice { @InitBinder protected void initBinder(WebDataBinder binder) { // 这里只需要LocalDateTime 如果需要转其他的,相应添加/修改 binder.registerCustomEditor(LocalDateTime.class, new PropertyEditorSupport() { @Override public void setAsText(String timestamp) throws IllegalArgumentException { if (!StringUtils.hasText(timestamp)) { setValue(null); } else { setValue(LocalDateTime.ofInstant(Instant.ofEpochMilli(Long.parseLong(timestamp)), ZoneId.systemDefault())); } } }); // 这里只需要LocalDateTime 如果需要转其他的,相应添加/修改 binder.registerCustomEditor(LocalDate.class, new PropertyEditorSupport() { @Override public void setAsText(String timestamp) throws IllegalArgumentException { if (!StringUtils.hasText(timestamp)) { setValue(null); } else { setValue(LocalDate.ofInstant(Instant.ofEpochMilli(Long.parseLong(timestamp)), ZoneId.systemDefault())); } } }); } } 相关知识点 时间差 精确时间差:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 long start = 1584328558000L; long now = 1584400558000L; Instant startTime = Instant.ofEpochMilli(start); LocalDateTime startTimeT = LocalDateTime.ofInstant(startTime, ZoneId.systemDefault()); Instant endTime = Instant.ofEpochMilli(now); LocalDateTime entTimeT = LocalDateTime.ofInstant(startTime, ZoneId.systemDefault()); Duration duration = Duration.between(startTimeT, entTimeT); // Duration duration = Duration.between(startTime, entTime); long day = duration.toDays(); long hours = duration.toHours(); long min = duration.toMinutes(); long millis= duration.toMillis(); long nanos = duration.toNanos(); 粗略时间差, 比如今天明天算一天\n1 2 3 4 5 6 7 8 9 10 11 long start = 1584328558000L; long now = 1584400558000L; Instant startTime = Instant.ofEpochMilli(start); LocalDate startTimeT = LocalDateTime.ofInstant(startTime, ZoneId.systemDefault()).toLocalDate(); Instant endTime = Instant.ofEpochMilli(now); LocalDate entTimeT = LocalDateTime.ofInstant(startTime, ZoneId.systemDefault()).toLocalDate(); Period period = Period.between(startTimeT, entTimeT); int years = period.getYears(); int months = period.getMonths(); int days = period.getDays(); ","permalink":"https://habyss.github.io/posts/tech/springboot_localdatetime/","summary":"SpringBoot中时间戳和LocalDateTime相关的接收和转换 前言 一般情况下, 前端和后端在时间格式的传递上都走的是时间戳（方便前端","title":"SpringBoot中时间戳和LocalDateTime相关的接收和转换"},{"content":"小鹤双拼 方案一 win + R，输入 regedit，打开注册表\n找到 计算机\\HKEY_CURRENT_USER\\Software\\Microsoft\\InputMethod\\Settings\\CHS 项\n新建一个名为 UserDefinedDoublePinyinScheme0 的字符串值，值为\n1 小鹤双拼*2*^*iuvdjhcwfg^xmlnpbksqszxkrltvyovt 方案二 新建文本文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Windows Registry Editor Version 5.00 [HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\InputMethod\\Settings\\CHS] \u0026#34;EnableExtraDomainType\u0026#34;=dword:00000001 \u0026#34;EnableSmartSelfLearning\u0026#34;=dword:00000000 \u0026#34;EnableVMode\u0026#34;=dword:00000000 \u0026#34;EnableHap\u0026#34;=dword:00000000 \u0026#34;EnablePeopleName\u0026#34;=dword:00000000 \u0026#34;DoublePinyinScheme\u0026#34;=dword:0000000a \u0026#34;EnableUMode\u0026#34;=dword:00000000 \u0026#34;EnableSmartFuzzyPinyin\u0026#34;=dword:00000000 \u0026#34;UserDefinedDoublePinyinScheme0\u0026#34;=\u0026#34;小鹤双拼*2*^*iuvdjhcwfg^xmlnpbksqszxkrltvyovt\u0026#34; \u0026#34;Enable Dynamic Candidate Ranking\u0026#34;=dword:00000000 \u0026#34;Enable self-learning\u0026#34;=dword:00000000 \u0026#34;Expand Double Pinyin\u0026#34;=dword:00000000 \u0026#34;Enable Double Pinyin\u0026#34;=dword:00000001 \u0026#34;LangBar Force On\u0026#34;=dword:00000000 \u0026#34;PinyinMixEnable\u0026#34;=dword:00000000 \u0026#34;ToolBarEnabled\u0026#34;=dword:00000000 重命名.reg, 并运行\n","permalink":"https://habyss.github.io/posts/tool/%E5%B0%8F%E9%B9%A4%E5%8F%8C%E6%8B%BC/","summary":"小鹤双拼 方案一 win + R，输入 regedit，打开注册表 找到 计算机\\HKEY_CURRENT_USER\\Software\\Microsoft\\I","title":"小鹤双拼"},{"content":"Mysql-explain id id相同时, 执行顺序由上而下 id不同时, 执行顺序由大到小, 一般为子查询 select_type 查询类型, 常见的值有:\nSIMPLE: 简单查询, 不包含UNION或者子查询 PRIMARY: 查询中如果包含子查询或其他部分, 则外层的SELECT将被标记为PRIMARY SUBQUERY: 子查询中的第一个SELECT NUION: 在UNION语句中, UNION之后出现的SELECT DERIVED: 在FROM中出现的子查询 UNION RESULT: UNION查询的结果 table 当前的数据表\npartitions 查询所匹配记录的分区, 对于未分区的表, 值为NULL\ntype 查询执行的类型, 最优排行\nsystem \u0026gt; const \u0026gt; eq_ref \u0026gt; ref \u0026gt; fulltext \u0026gt; ref_or_null \u0026gt; index_merge \u0026gt; unique_subquery \u0026gt; index_subquery \u0026gt; range \u0026gt; index \u0026gt; ALL\nsystem: 表中只有一行数据, 是const的一种特例 const: 表中最多只有一行匹配的记录 eq_ref: 连表查询时, 前一张表的行在当前表中只有一行与之对应(除了system与const最好的连表方式) ref: 使用普通索引作为查询条件, 查询结果可能找到多行匹配的记录 fulltext: 全文索引 ref_or_null: 使用普通索引作为查询条件 , 查询结果可能找到多行匹配的记录, 还查询了值为NULL的行 index_merge: 当查询条件使用多个索引时, index_merge表示开启了Index Merge优化 unique_subquery: eq_ref类似, 在一些使用IN的子查询中, 使用唯一索引 index_subquery: 与unique_subquery类似, 在IN子查询中, 使用了普通索引 range: 对索引列进行范围查询 index: 查询便利了整个索引树, ALL: 遍历全表, 很可能读磁盘, 速度最慢 possible_key 可能被使用的索引, 不一定被查询实际使用\nkey 查询中实际使用到的索引, 如果为NULL, 则表示为建立索引或索引失效\nkey_len 查询索引时使用的字节数, 在满足前提的需求下, 越小越好\nref 在查询索引时, 那些列或常量被用来与索引值比较\nrows 可能查询时需要遍历的行数\nfiltered 估算经过查询条件筛选出的列数的百分比\nExtra 查询时的额外信息\n当包含Using filesort或Using temporary, 需要优化\nUsing filesort: 在排序时使用了外部的索引排序, 没有使用表内的索引进行排序 Using temporary: 需要创建临时表来存储查询的结果, 常见于ORDER BY和GROUP BY Using index: 使用了索引覆盖, 查询效率非常高 Using where: 使用了WHERE子句进行条件过滤, 一般在没有使用到索引的时候出现 Impossible where: 表示where子句的结果总是false且无法查到任意行 Using join buffer(Block Nested Loop): 连表查询时, 当被驱动表没有使用索引时, 会先将驱动表读到join buffer中, 再遍历被驱动表与驱动表进行查询 Using json buffer(Batched Key Access): 与Using join buffer(Block Nested Loop)类似, 使用的是BKA算法\u0026ndash; 前提是被驱动表有索引可用 ","permalink":"https://habyss.github.io/posts/tech/mysql_explain/","summary":"Mysql-explain id id相同时, 执行顺序由上而下 id不同时, 执行顺序由大到小, 一般为子查询 select_type 查询类型, 常见的值有: SIMPLE: 简单查询, 不包含UNION或者子查询 PRIMARY: 查","title":"Mysql Explain 简解"},{"content":"Hugo+Github Pages 1. 安装Scoop win系统, 在hugo官网中也推荐了使用Scoop来进行包管理\n打开PowerShell并运行, 保证允许本地脚本的执行\n1 set-executionpolicy remotesigned -scope currentuser 执行安装命令\n1 iex (new-object net.webclient).downloadstring(\u0026#39;https://get.scoop.sh\u0026#39;) 安装成功验证\n1 scoop help 2. 安装Hugo 安装Hugo的extend版本\n1 scoop install hugo-extended 安装成功验证\n1 hugo version 3. 创建Blog hugo new site MyBlog -f yml 下载zip解压到themes, 并重命名为PaperMod 修改config.yml https://shaohanyun.top/posts/env/blog_build2/\nhttps://www.sulvblog.cn/posts/blog/build_hugo/\n","permalink":"https://habyss.github.io/posts/tech/%E6%B5%8B%E8%AF%95/","summary":"Hugo+Github Pages 1. 安装Scoop win系统, 在hugo官网中也推荐了使用Scoop来进行包管理 打开PowerShell并运行, 保证允许本地脚本的执行 1 set-executionpolicy","title":"测试"}]