<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>SpringBoot on 叶灰灰的小窝</title>
    <link>https://habyss.github.io/tags/springboot/</link>
    <description>Recent content in SpringBoot on 叶灰灰的小窝</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 23 Aug 2022 15:36:53 +0800</lastBuildDate><atom:link href="https://habyss.github.io/tags/springboot/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>基于mybatis-plus typeHandler 加解密简单实现</title>
      <link>https://habyss.github.io/posts/tech/mybatis_plus_typehandler/</link>
      <pubDate>Tue, 23 Aug 2022 15:36:53 +0800</pubDate>
      
      <guid>https://habyss.github.io/posts/tech/mybatis_plus_typehandler/</guid>
      <description>💡 不可以对查询参数加解密 💡 不会修改原对象数据 💡 对于手写sql需要特殊指定 💡 对于非sql的CRUD可自动加解密 1. 非sql查询 — 数据库实体类 1 2</description>
    </item>
    
    <item>
      <title>OpenFeign优化</title>
      <link>https://habyss.github.io/posts/tech/openfeign/</link>
      <pubDate>Fri, 24 Jun 2022 15:36:53 +0800</pubDate>
      
      <guid>https://habyss.github.io/posts/tech/openfeign/</guid>
      <description>一、超时优化 OpenFeign 底层内置了 Ribbon 框架，并且使用了 Ribbon 的请求连接超时时间和请求处理超时时间作为其超时时间，而 Ribbon 默认的请求连接超时时间和请求处理超时时间</description>
    </item>
    
    <item>
      <title>resilience4j-spring-boot2 熔断</title>
      <link>https://habyss.github.io/posts/tech/resilience4j_%E7%86%94%E6%96%AD/</link>
      <pubDate>Thu, 12 May 2022 15:36:53 +0800</pubDate>
      
      <guid>https://habyss.github.io/posts/tech/resilience4j_%E7%86%94%E6%96%AD/</guid>
      <description>pom 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 &amp;lt;dependencies&amp;gt; &amp;lt;!-- resilience4j 按需引入 或 all--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;io.github.resilience4j&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;resilience4j-ratelimiter&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${resilience4jVersion}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- resilience4j 按需引入 或 all--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;io.github.resilience4j&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;resilience4j-all&amp;lt;/artifactId&amp;gt; version&amp;gt;${resilience4jVersion}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;io.github.resilience4j&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;resilience4j-spring-boot2&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${resilience4jVersion}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- 想使用resilienc</description>
    </item>
    
    <item>
      <title>TraceId 日志跟踪</title>
      <link>https://habyss.github.io/posts/tech/springboot_traceid/</link>
      <pubDate>Wed, 23 Oct 2019 15:36:53 +0800</pubDate>
      
      <guid>https://habyss.github.io/posts/tech/springboot_traceid/</guid>
      <description>全局拦截, 在 MDC 中插入自定义 traceId 💡 MDC（Mapped Diagnostic Context）机制实现，支持主流的Log4j、Log4j2和Logback日志框架。 1</description>
    </item>
    
    <item>
      <title>rabbitmq ack 探索</title>
      <link>https://habyss.github.io/posts/tech/rabbitmq_ack/</link>
      <pubDate>Sun, 16 Jun 2019 15:36:53 +0800</pubDate>
      
      <guid>https://habyss.github.io/posts/tech/rabbitmq_ack/</guid>
      <description>RabbitMq 生产者确认消息被消费 探索 消费者手动ack的一些状态, 生产者是不能准确得知的. 例如: 1 2 // 处理失败 重新进入队列 继续消费 channel.basicNack(msg.getMessageProperties().getDeliveryTag(), false,true); 当消费者把消息重新</description>
    </item>
    
    <item>
      <title>rabbitmq限流Qos 多个消费者同时消费一个消息</title>
      <link>https://habyss.github.io/posts/tech/rabbitmq_qos_random/</link>
      <pubDate>Mon, 20 May 2019 15:36:53 +0800</pubDate>
      
      <guid>https://habyss.github.io/posts/tech/rabbitmq_qos_random/</guid>
      <description>高并发情况下 RabbitMQ 服务限流 spring下默认为250, 若默写服务需要限流或者需要强制顺序性执行, 则需要自定义qos 1 2 3 4 5 @RabbitHandler @RabbitListener(queues = QueueConstant.RE_SMS_ORDER_NOT_PAID_QUEUE) public void process(Channel channel, Message message)</description>
    </item>
    
    <item>
      <title>rabbitmq实现延时队列</title>
      <link>https://habyss.github.io/posts/tech/rabbitmq_delay/</link>
      <pubDate>Fri, 12 Apr 2019 15:36:53 +0800</pubDate>
      
      <guid>https://habyss.github.io/posts/tech/rabbitmq_delay/</guid>
      <description>方式一: 原生RabbitMq延时队列 💡缺点: 每个队列的消息是顺序的, 靠后的过期时间短的消息并不能先执行 配置队列 机制 “死信”是RabbitMQ</description>
    </item>
    
    <item>
      <title>基于springboot常用aop方式</title>
      <link>https://habyss.github.io/posts/tech/springboot_aop/</link>
      <pubDate>Sun, 03 Feb 2019 15:36:53 +0800</pubDate>
      
      <guid>https://habyss.github.io/posts/tech/springboot_aop/</guid>
      <description>方式一: 基于表达式 例如简单日志打印: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 @Slf4j @Aspect @Component public class WebLogAspect { /** * xxx包及其子包下的以Contro</description>
    </item>
    
    <item>
      <title>@Transactional失效排查</title>
      <link>https://habyss.github.io/posts/tech/transactional/</link>
      <pubDate>Thu, 03 Jan 2019 15:36:53 +0800</pubDate>
      
      <guid>https://habyss.github.io/posts/tech/transactional/</guid>
      <description>@Transactional失效 整合shiro之后，UserRealm类里自动注入的service中的@Transactional注解失效 解</description>
    </item>
    
    <item>
      <title>$ref-fastjson排查</title>
      <link>https://habyss.github.io/posts/tech/ref-fastjson/</link>
      <pubDate>Thu, 20 Dec 2018 15:36:53 +0800</pubDate>
      
      <guid>https://habyss.github.io/posts/tech/ref-fastjson/</guid>
      <description>$ref-fastjson 问题排查 问题排查 项目返回的数据中出现$ref数据 查询得知是fastjson的特性循环引用 fastjson支持循环引用，并且是缺省打开的。 当</description>
    </item>
    
    <item>
      <title>SpringBoot中时间戳和LocalDateTime相关的接收和转换</title>
      <link>https://habyss.github.io/posts/tech/springboot_localdatetime/</link>
      <pubDate>Mon, 10 Dec 2018 15:36:53 +0800</pubDate>
      
      <guid>https://habyss.github.io/posts/tech/springboot_localdatetime/</guid>
      <description>SpringBoot中时间戳和LocalDateTime相关的接收和转换 前言 一般情况下, 前端和后端在时间格式的传递上都走的是时间戳（方便前端</description>
    </item>
    
  </channel>
</rss>
